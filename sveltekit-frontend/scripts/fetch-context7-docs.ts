#!/usr/bin/env node
import fs from 'fs/promises';
import path from 'path';

// Context7 MCP Server endpoint
const MCP_CONTEXT7_ENDPOINT = 'http://localhost:4000'; // Context7 wrapper endpoint

// Documentation libraries to fetch
const LIBRARIES_TO_FETCH = [
  { id: 'typescript', name: 'TypeScript', topics: ['types', 'interfaces', 'generics', 'decorators', 'modules'] },
  { id: 'webgpu', name: 'WebGPU', topics: ['shaders', 'buffers', 'compute', 'rendering', 'pipelines'] },
  { id: 'postgresql', name: 'PostgreSQL 17', topics: ['jsonb', 'indexes', 'performance', 'replication', 'partitioning'] },
  { id: 'drizzle-orm', name: 'Drizzle ORM', topics: ['schema', 'queries', 'migrations', 'relations', 'transactions'] }
];

// Output directory for documentation
const DOCS_OUTPUT_DIR = path.join(process.cwd(), 'sveltekit-frontend', 'docs', 'context7-library-docs');

interface LibraryDocsResponse {
  content: string;
  metadata: {
    library: string;
    version?: string;
    topic?: string;
    tokenCount: number;
  };
  snippets?: {
    title: string;
    code: string;
    description: string;
  }[];
}

async function fetchLibraryDocs(libraryId: string, topic?: string): Promise<LibraryDocsResponse | null> {
  try {
    console.log(`üìö Fetching ${libraryId} documentation${topic ? ` for topic: ${topic}` : ''}...`);
    
    const response = await fetch(`${MCP_CONTEXT7_ENDPOINT}/tools/call`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'User-Agent': 'Context7-Docs-Fetcher/1.0'
      },
      body: JSON.stringify({
        name: 'get_library_docs',
        arguments: {
          context7CompatibleLibraryID: libraryId,
          topic: topic,
          tokens: 15000,
          format: 'markdown'
        }
      })
    });

    if (!response.ok) {
      console.error(`‚ùå Failed to fetch ${libraryId} docs: ${response.status} ${response.statusText}`);
      return null;
    }

    const result = await response.json();
    
    if (result.success && result.result) {
      return result.result as LibraryDocsResponse;
    }
    
    console.warn(`‚ö†Ô∏è  No content returned for ${libraryId}`);
    return null;
  } catch (error) {
    console.error(`‚ùå Error fetching ${libraryId} docs:`, error);
    return null;
  }
}

async function saveDocumentation(libraryName: string, content: string, topic?: string): Promise<void> {
  try {
    // Create output directory if it doesn't exist
    await fs.mkdir(DOCS_OUTPUT_DIR, { recursive: true });
    
    // Generate filename
    const filename = topic 
      ? `${libraryName.toLowerCase().replace(/\s+/g, '-')}-${topic}.md`
      : `${libraryName.toLowerCase().replace(/\s+/g, '-')}.md`;
    
    const filepath = path.join(DOCS_OUTPUT_DIR, filename);
    
    // Add header to the content
    const fullContent = `# ${libraryName} Documentation${topic ? ` - ${topic}` : ''}

Generated by Context7 MCP Server on ${new Date().toISOString()}

---

${content}
`;
    
    // Save the file
    await fs.writeFile(filepath, fullContent, 'utf-8');
    console.log(`‚úÖ Saved ${libraryName}${topic ? ` (${topic})` : ''} documentation to ${filename}`);
  } catch (error) {
    console.error(`‚ùå Error saving ${libraryName} documentation:`, error);
  }
}

async function generateIndexFile(libraries: typeof LIBRARIES_TO_FETCH): Promise<void> {
  try {
    const indexContent = `# Context7 Library Documentation Index

Generated on ${new Date().toISOString()}

## Available Documentation

${libraries.map(lib => {
  const baseFile = `${lib.name.toLowerCase().replace(/\s+/g, '-')}.md`;
  const topicFiles = lib.topics.map(topic => 
    `  - [${topic}](./${lib.name.toLowerCase().replace(/\s+/g, '-')}-${topic}.md)`
  ).join('\n');
  
  return `### ${lib.name}
- [Main Documentation](./${baseFile})
${topicFiles}`;
}).join('\n\n')}

## Usage

These documentation files were fetched from the Context7 MCP Server and contain:
- API references
- Code examples
- Best practices
- Integration guides

## Updating Documentation

To refresh the documentation, run:
\`\`\`bash
npm run fetch-context7-docs
\`\`\`

Or manually:
\`\`\`bash
npx tsx scripts/fetch-context7-docs.ts
\`\`\`
`;

    const indexPath = path.join(DOCS_OUTPUT_DIR, 'README.md');
    await fs.writeFile(indexPath, indexContent, 'utf-8');
    console.log('‚úÖ Generated documentation index');
  } catch (error) {
    console.error('‚ùå Error generating index file:', error);
  }
}

async function main() {
  console.log('üöÄ Starting Context7 documentation fetch...\n');
  
  // Check if Context7 server is running
  try {
    const healthCheck = await fetch(`${MCP_CONTEXT7_ENDPOINT}/health`);
    if (!healthCheck.ok) {
      console.error('‚ö†Ô∏è  Context7 MCP server may not be running properly');
    }
  } catch (error) {
    console.error('‚ùå Context7 MCP server is not accessible. Please ensure it\'s running on port 4000');
    console.log('Run: npm run start:mcp-context7');
    process.exit(1);
  }
  
  const fetchedLibraries: typeof LIBRARIES_TO_FETCH = [];
  
  for (const library of LIBRARIES_TO_FETCH) {
    console.log(`\nüìñ Processing ${library.name}...`);
    
    // Fetch main documentation
    const mainDocs = await fetchLibraryDocs(library.id);
    if (mainDocs && mainDocs.content) {
      await saveDocumentation(library.name, mainDocs.content);
      fetchedLibraries.push(library);
    }
    
    // Fetch topic-specific documentation
    for (const topic of library.topics) {
      const topicDocs = await fetchLibraryDocs(library.id, topic);
      if (topicDocs && topicDocs.content) {
        await saveDocumentation(library.name, topicDocs.content, topic);
      }
      
      // Add a small delay to avoid overwhelming the server
      await new Promise(resolve => setTimeout(resolve, 500));
    }
  }
  
  // Generate index file
  await generateIndexFile(fetchedLibraries);
  
  console.log('\n‚ú® Documentation fetch complete!');
  console.log(`üìÅ Documentation saved to: ${DOCS_OUTPUT_DIR}`);
}

// Run the main function
main().catch(console.error);