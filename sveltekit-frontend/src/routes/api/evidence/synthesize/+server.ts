/// <reference types="vite/client" />
import { URL } from "url";
import type { RequestHandler } from './$types';


// Evidence Synthesis API - Context7 Best Practices Implementation
// File: src/routes/api/evidence/synthesize/+server.ts

import { json } from "@sveltejs/kit";
import { db } from "$lib/server/db/index";
import { eq, and, inArray } from "drizzle-orm";
import type { RAGResponse } from "$lib/types/rag";

import { createClient } from "redis";
import { randomUUID } from "crypto";

export interface SynthesisRequest {
    evidenceIds: string[];
    synthesisType: "merge" | "compare" | "timeline" | "correlation";
    prompt?: string;
    caseId: string;
    title: string;
    description?: string;
}

export interface SynthesisResult {
    synthesizedEvidence: any;
    embedding: number[];
    ragScore: number;
    confidence: number;
    sources: string[];
}

// Redis client for real-time updates let redisClient: any = null; async function initRedis(): Promise<any> { if (!redisClient) { try { redisClient = createClient({ url: import.meta.env.REDIS_URL || "redis://localhost:6379" }); await redisClient.connect(); } catch (error: any) { console.error("Redis connection failed:", error); } } } async function publishSynthesisUpdate( type: string, data: any, userId?: string ): Promise<any> { if (redisClient) { try { await redisClient.publish( "synthesis_update", JSON.stringify({ type, timestamp: new Date().toISOString(), userId, ...data }) ); } catch (error: any) { console.error("Failed to publish synthesis update:", error); } } } export const POST: RequestHandler = async ({ request, locals }) => { if (!locals.user) { return json({ error: "Unauthorized" }, { status: 401 }); } try { await initRedis(); const { evidenceIds, synthesisType, prompt, caseId, title, description }: SynthesisRequest = await request.json(); // Validate inputs if (!evidenceIds || evidenceIds.length < 2) { return json( { error: "At least 2 evidence items required for synthesis" }, { status: 400 } ); } if (!caseId || !title) { return json({ error: "Case ID and title are required" }, { status: 400 }); } // Verify user has access to case const caseRecord = await db .select() .from(cases) .where(and(eq(cases.id, caseId), eq(cases.createdBy, locals.user.id))) .limit(1); if (!caseRecord.length) { return json( { error: "Case not found or access denied" }, { status: 404 } ); } // Fetch evidence items to synthesize const evidenceItems = await db .select() .from(evidence) .where( and(inArray(evidence.id, evidenceIds), eq(evidence.caseId, caseId)) ); if (evidenceItems.length !== evidenceIds.length) { return json({ error: "Some evidence items not found" }, { status: 404 }); } // Perform synthesis const synthesisResult = await synthesizeEvidence( evidenceItems, synthesisType, prompt, locals.user.id, caseId ); // Create new synthesized evidence record const synthesizedEvidence = await db .insert(evidence) .values({ title, description: description || `Synthesized from ${evidenceItems.length} evidence items`, caseId, evidenceType: "synthesized", subType: synthesisType, aiAnalysis: { synthesisMethod: synthesisType, sourceEvidenceIds: evidenceIds, synthesisTimestamp: new Date().toISOString(), confidence: synthesisResult.confidence, ragScore: synthesisResult.ragScore }, aiSummary: synthesisResult.synthesizedEvidence.summary, summary: synthesisResult.synthesizedEvidence.analysis, tags: [ "synthesized", synthesisType, ...extractTagsFromEvidence(evidenceItems), ], chainOfCustody: [ { action: "synthesis_created", userId: locals.user.id, timestamp: new Date().toISOString(), details: { sourceCount: evidenceItems.length, method: synthesisType } }, ], uploadedBy: locals.user.id, isAdmissible: true, // Synthesized evidence requires manual review confidentialityLevel: "restricted" }) .returning(); // Add to enhanced RAG with high-score ranking await addToEnhancedRAG( synthesizedEvidence[0], synthesisResult.embedding, synthesisResult.ragScore, synthesisType ); // Publish real-time update await publishSynthesisUpdate( "SYNTHESIS_CREATED", { evidenceId: synthesizedEvidence[0].id, caseId, synthesisType, sourceCount: evidenceItems.length, ragScore: synthesisResult.ragScore, data: synthesizedEvidence[0] }, locals.user.id ); return json({ success: true, synthesizedEvidence: synthesizedEvidence[0], metadata: { ragScore: synthesisResult.ragScore, confidence: synthesisResult.confidence, sources: synthesisResult.sources, embeddingDimensions: synthesisResult.embedding.length, synthesisType, sourceEvidenceCount: evidenceItems.length } }); } catch (error: any) { console.error("Evidence synthesis failed:", error); return json({ error: "Evidence synthesis failed" }, { status: 500 }); } }; // Core synthesis logic with Context7 best practices async function synthesizeEvidence( evidenceItems: any[], synthesisType: string, customPrompt: string | undefined, userId: string, caseId: string ): Promise<SynthesisResult> { // Prepare synthesis context const evidenceContext = evidenceItems.map((item) => ({ id: item.id, title: item.title, description: item.description, content: item.summary || item.description, type: item.evidenceType, subType: item.subType, tags: item.tags, aiAnalysis: item.aiAnalysis, collectedAt: item.collectedAt, location: item.location })); // Generate synthesis prompt based on type const synthesisPrompt = generateSynthesisPrompt( evidenceContext, synthesisType, customPrompt ); // Use enhanced RAG for context-aware synthesis const ragResult = await enhancedRAGService.query(synthesisPrompt, { caseId: caseId, documentTypes: ["evidence", "legal"] }); // Generate embeddings for the synthesized content const analysis = ragResult.answer || "No analysis available"; const recommendations = [ "Comprehensive analysis completed", "Review source evidence for details", ]; const synthesizedContent = `${analysis}\n\nRecommendations:\n${recommendations.join("\n")}`; const embedding = (await aiService.generateEmbedding(synthesizedContent, { provider: "tauri-legal-bert", legalDomain: true })) as number[]; // Calculate high RAG score based on multiple factors const ragScore = calculateHighRAGScore( evidenceItems, ragResult, embedding, synthesisType ); return { synthesizedEvidence: { summary: analysis, analysis: `Synthesis Analysis (${synthesisType}):\n\n${analysis}\n\nRecommendations:\n- ${recommendations.join("\n- ")}`, recommendations: recommendations, methodology: synthesisType, sourceCount: evidenceItems.length, correlations: identifyCorrelations(evidenceItems), timeline: synthesisType === "timeline" ? buildTimeline(evidenceItems) : null, patterns: identifyPatterns(evidenceItems) }, embedding, ragScore, confidence: ragResult.confidence || 0.8, sources: ragResult.sources.map((s) => s.content) || [] }; } function generateSynthesisPrompt( evidenceContext: any[], synthesisType: string, customPrompt?: string ): string { const basePrompt = `Legal Evidence Synthesis Task Synthesis Type: ${synthesisType} Evidence Items: ${evidenceContext.length} Evidence Data: ${evidenceContext .map( (item, idx) => ` ${idx + 1}. Title: ${item.title} Type: ${item.type}${item.subType ? ` (${item.subType})` : ""} Content: ${item.content} Tags: ${item.tags?.join(", ") || "None"} ${item.collectedAt ? `Collected: ${new Date(item.collectedAt).toLocaleDateString()}` : ""} ${item.location ? `Location: ${item.location}` : ""} ` ) .join("\n")} ${customPrompt || ""} Instructions: - Perform ${synthesisType} synthesis of the evidence - Identify patterns, correlations, and inconsistencies - Provide legal analysis with supporting reasoning - Generate actionable recommendations - Assess evidentiary value and admissibility implications - ${synthesisType === "timeline" ? "Create chronological sequence with gaps identified" : ""} - ${synthesisType === "correlation" ? "Focus on connections and causal relationships" : ""} - ${synthesisType === "compare" ? "Highlight similarities, differences, and contradictions" : ""} - ${synthesisType === "merge" ? "Combine evidence into coherent narrative" : ""} Provide comprehensive analysis:`; return basePrompt; } function calculateHighRAGScore( evidenceItems: any[], ragResult: any, embedding: number[], synthesisType: string ): number { let score = ragResult.metadata.ragScore || 0.5; // Boost score based on evidence quality const avgEvidenceQuality = evidenceItems.reduce((sum, item) => { let quality = 0.5; if (item.isAdmissible) quality += 0.2; if ( item.aiAnalysis?.confidence && Number(item.aiAnalysis.confidence) > 0.8 ) quality += 0.2; if (item.tags?.length > 3) quality += 0.1; if (item.chainOfCustody?.length > 0) quality += 0.1; return sum + quality; }, 0) / evidenceItems.length; score = score * 0.6 + avgEvidenceQuality * 0.4; // Synthesis type multipliers const typeMultipliers = { correlation: 1.2, // Highest value for correlations timeline: 1.15, compare: 1.1, merge: 1.0 }; score *= typeMultipliers[synthesisType as keyof typeof typeMultipliers] || 1.0; // Embedding quality boost if (embedding.length >= 384) { const embeddingMagnitude = Math.sqrt( embedding.reduce((sum, val) => sum + val * val, 0) ); if (embeddingMagnitude > 0.8) score += 0.1; } // Source diversity bonus const evidenceTypes = new Set(evidenceItems.map((item) => item.evidenceType)); if (evidenceTypes.size > 2) score += 0.05; return Math.min(0.95, Math.max(0.1, score)); } function extractTagsFromEvidence(evidenceItems: any[]): string[] { const allTags = evidenceItems.flatMap((item) => item.tags || []); const uniqueTags = [...new Set(allTags)]; return uniqueTags.slice(0, 10); // Limit to 10 most relevant tags } function identifyCorrelations(evidenceItems: any[]): unknown[] { const correlations = []; // Find temporal correlations const datedItems = evidenceItems.filter((item) => item.collectedAt); if (datedItems.length > 1) { correlations.push({ type: "temporal", description: "Evidence items with overlapping timeframes", items: datedItems.map((item) => item.id) }); } // Find location correlations const locatedItems = evidenceItems.filter((item) => item.location); if (locatedItems.length > 1) { correlations.push({ type: "spatial", description: "Evidence items from related locations", items: locatedItems.map((item) => item.id) }); } // Find tag correlations const taggedItems = evidenceItems.filter((item) => item.tags?.length > 0); if (taggedItems.length > 1) { correlations.push({ type: "thematic", description: "Evidence items with common themes", items: taggedItems.map((item) => item.id) }); } return correlations; } function buildTimeline(evidenceItems: any[]): unknown { const datedItems = evidenceItems .filter((item) => item.collectedAt) .sort( (a, b) => new Date(a.collectedAt).getTime() - new Date(b.collectedAt).getTime() ); if (datedItems.length === 0) return null; return { events: datedItems.map((item) => ({ date: item.collectedAt, evidenceId: item.id, title: item.title, type: item.evidenceType, location: item.location })), timespan: { start: datedItems[0].collectedAt, end: datedItems[datedItems.length - 1].collectedAt }, gaps: identifyTimelineGaps(datedItems) }; } function identifyTimelineGaps(datedItems: any[]): unknown[] { const gaps = []; for (let i = 1; i < datedItems.length; i++) { const prev = new Date(datedItems[i - 1].collectedAt); const curr = new Date(datedItems[i].collectedAt); const diffDays = (curr.getTime() - prev.getTime()) / (1000 * 60 * 60 * 24); if (diffDays > 7) { // Gap of more than 7 days gaps.push({ start: prev.toISOString(), end: curr.toISOString(), days: Math.floor(diffDays) }); } } return gaps; } function identifyPatterns(evidenceItems: any[]): unknown[] { const patterns = []; // Evidence type patterns const typeFreq = evidenceItems.reduce( (acc, item) => { acc[item.evidenceType] = (acc[item.evidenceType] || 0) + 1; return acc; }, {} as Record<string, number> ); const dominantType = Object.entries(typeFreq).reduce((a, b) => a[1] > b[1] ? a : b ); if ((dominantType[1] as number) > evidenceItems.length / 2) { patterns.push({ type: "evidence_dominance", description: `${dominantType[0]} evidence is dominant (${dominantType[1]}/${evidenceItems.length} items)`, value: dominantType[0], count: dominantType[1] as number }); } // Quality patterns const highQualityCount = evidenceItems.filter( (item) => item.isAdmissible && item.aiAnalysis?.confidence && Number(item.aiAnalysis.confidence) > 0.8 ).length; if (highQualityCount > evidenceItems.length * 0.7) { patterns.push({ type: "high_quality", description: "High proportion of high-quality evidence", ratio: highQualityCount / evidenceItems.length }); } return patterns; } async function addToEnhancedRAG( synthesizedEvidence: any, embedding: number[], ragScore: number, synthesisType: string ): Promise<void> { try { // Add to RAG system with high-priority ranking const ragContent = `${synthesizedEvidence.title}\n\n${synthesizedEvidence.summary}\n\nAnalysis: ${synthesizedEvidence.aiSummary}`; await enhancedRAGService.indexDocument({ id: synthesizedEvidence.id, title: `Synthesized Evidence - ${synthesisType}`, content: ragContent, type: "synthesized_evidence", metadata: { caseId: synthesizedEvidence.caseId, ragScore, priority: ragScore > 0.8 ? "high" : ragScore > 0.6 ? "medium" : "normal", embedding, synthesized: true, timestamp: new Date().toISOString(), tags: synthesizedEvidence.tags, synthesisMethod: synthesizedEvidence.aiAnalysis?.synthesisMethod, sourceCount: Array.isArray( synthesizedEvidence.aiAnalysis?.sourceEvidenceIds ) ? synthesizedEvidence.aiAnalysis.sourceEvidenceIds.length : 0 } }); console.log(`âœ… Added synthesized evidence to RAG with score: ${ragScore}`); } catch (error: any) { console.error("Failed to add to enhanced RAG:", error); } } // Get synthesis suggestions endpoint export const GET: RequestHandler = async ({ url, locals }) => { if (!locals.user) { return json({ error: "Unauthorized" }, { status: 401 }); } const caseId = url.searchParams.get("caseId"); if (!caseId) { return json({ error: "Case ID required" }, { status: 400 }); } try { // Get all evidence for the case const caseEvidence = await db .select() .from(evidence) .where(eq(evidence.caseId, caseId)); // Use AI to suggest synthesis opportunities const suggestions = await generateSynthesisSuggestions(caseEvidence); return json({ suggestions, metadata: { totalEvidence: caseEvidence.length, suggestionsGenerated: suggestions.length, timestamp: new Date().toISOString() } }); } catch (error: any) { console.error("Failed to generate synthesis suggestions:", error); return json({ error: "Failed to generate suggestions" }, { status: 500 }); } }; async function generateSynthesisSuggestions( evidenceItems: any[] ): Promise<any[]> { if (evidenceItems.length < 2) return []; const suggestions = []; // Find timeline synthesis opportunities const timelineItems = evidenceItems.filter( (item) => item.collectedAt && (item.evidenceType === "document" || item.evidenceType === "photo") ); if (timelineItems.length >= 2) { suggestions.push({ type: "timeline", evidenceIds: timelineItems.slice(0, 5).map((item) => item.id), title: "Timeline Synthesis", description: "Create chronological sequence of events", confidence: 0.85, priority: "high", estimatedValue: calculateSuggestionValue(timelineItems, "timeline") }); } // Find correlation opportunities const digitalItems = evidenceItems.filter( (item) => item.evidenceType === "digital" && item.tags?.includes("communication") ); if (digitalItems.length >= 2) { suggestions.push({ type: "correlation", evidenceIds: digitalItems.slice(0, 3).map((item) => item.id), title: "Digital Evidence Correlation", description: "Analyze communication patterns and digital footprints", confidence: 0.9, priority: "high", estimatedValue: calculateSuggestionValue(digitalItems, "correlation") }); } // Find comparison opportunities const similarItems = findSimilarEvidence(evidenceItems); if (similarItems.length >= 2) { suggestions.push({ type: "compare", evidenceIds: similarItems.slice(0, 4).map((item) => item.id), title: "Evidence Comparison", description: "Compare similar evidence items for inconsistencies", confidence: 0.75, priority: "medium", estimatedValue: calculateSuggestionValue(similarItems, "compare") }); } // Find merge opportunities const fragmentedItems = evidenceItems.filter( (item) => item.description?.includes("partial") || item.tags?.includes("fragment") ); if (fragmentedItems.length >= 2) { suggestions.push({ type: "merge", evidenceIds: fragmentedItems.map((item) => item.id), title: "Evidence Merge", description: "Combine fragmented evidence into coherent narrative", confidence: 0.8, priority: "medium", estimatedValue: calculateSuggestionValue(fragmentedItems, "merge") }); } return suggestions .sort((a, b) => b.estimatedValue - a.estimatedValue) .slice(0, 5); } function findSimilarEvidence(evidenceItems: any[]): unknown[] { // Simple similarity based on tags and evidence type const typeGroups = evidenceItems.reduce( (acc, item) => { const key = `${item.evidenceType}-${item.subType || "general"}`; if (!acc[key]) acc[key] = []; acc[key].push(item); return acc; }, {} as Record<string, unknown[]> ); // Return items from the largest group with similar evidence const typeGroupValues = Object.values(typeGroups) as any[][]; const largestGroup = typeGroupValues.reduce( (max, group) => (group.length > max.length ? group : max), [] as any[] ); return largestGroup.length >= 2 ? largestGroup : []; } function calculateSuggestionValue(items: any[], synthesisType: string): number { let value = items.length * 0.2; // Base value from quantity // Quality multiplier const qualityScore = items.reduce((sum, item) => { let score = 0.5; if (item.isAdmissible) score += 0.2; if ( item.aiAnalysis?.confidence && Number(item.aiAnalysis.confidence) > 0.8 ) score += 0.2; if (item.tags?.length > 2) score += 0.1; return sum + score; }, 0) / items.length; value *= qualityScore; // Type-specific multipliers const typeMultipliers = { correlation: 1.3, timeline: 1.2, compare: 1.1, merge: 1.0 }; value *= typeMultipliers[synthesisType as keyof typeof typeMultipliers] || 1.0; return Math.round(value * 100) / 100; } ;