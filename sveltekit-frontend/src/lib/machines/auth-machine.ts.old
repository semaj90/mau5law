import { createMachine, assign } from 'xstate';
import { productionServiceClient } from '$lib/services/production-service-client';

// Authentication context interface
interface AuthContext {
  user: {
    id?: string;
    email?: string;
    firstName?: string;
    lastName?: string;
    role?: string;
    department?: string;
    jurisdiction?: string;
    permissions?: string[];
    isActive?: boolean;
    emailVerified?: boolean;
  } | null;
  session: {
    id?: string;
    expiresAt?: Date;
    fresh?: boolean;
  } | null;
  error?: string;
  isLoading: boolean;
  deviceInfo?: {
    userAgent?: string;
    platform?: string;
    language?: string;
    timezone?: string;
    securityScore?: number;
  };
  loginAttempts: number;
  maxLoginAttempts: number;
  lastLoginAttempt?: Date;
  lockoutUntil?: Date;
  twoFactorRequired: boolean;
  registrationData?: unknown;
}

// Authentication events
type AuthEvent =
  | { type: 'START_LOGIN'; data: LoginData }
  | { type: 'START_REGISTRATION'; data: RegistrationData }
  | { type: 'LOGIN_SUCCESS'; data: { user: any; session: any } }
  | { type: 'LOGIN_FAILURE'; data: { error: string } }
  | { type: 'REGISTRATION_SUCCESS'; data: { user: any } }
  | { type: 'REGISTRATION_FAILURE'; data: { error: string } }
  | { type: 'LOGOUT' }
  | { type: 'SESSION_EXPIRED' }
  | { type: 'REQUIRE_TWO_FACTOR' }
  | { type: 'TWO_FACTOR_SUCCESS'; data: { session: any } }
  | { type: 'TWO_FACTOR_FAILURE'; data: { error: string } }
  | { type: 'VERIFY_EMAIL' }
  | { type: 'EMAIL_VERIFIED' }
  | { type: 'RESET_PASSWORD'; data: { email: string } }
  | { type: 'PASSWORD_RESET_SENT' }
  | { type: 'ACCOUNT_LOCKED' }
  | { type: 'UNLOCK_ACCOUNT' }
  | { type: 'UPDATE_PROFILE'; data: any }
  | { type: 'PROFILE_UPDATED' }
  | { type: 'RETRY' };

interface LoginData {
  email: string;
  password: string;
  rememberMe?: boolean;
  twoFactorCode?: string;
  deviceInfo?: unknown;
}

interface RegistrationData {
  email: string;
  firstName: string;
  lastName: string;
  password: string;
  role: string;
  department: string;
  jurisdiction: string;
  badgeNumber?: string;
  enableTwoFactor?: boolean;
  deviceInfo?: unknown;
}

// Authentication services
const authServices = {
  // Login service with production service client integration
  login: async (context: AuthContext, event: any) => {
    const { email, password, rememberMe, twoFactorCode, deviceInfo } = event.data;

    try {
      // Use production service client for enhanced authentication
      const response = await productionServiceClient.request({
        method: 'POST',
        path: '/auth/login',
        body: {
          email,
          password,
          rememberMe,
          twoFactorCode,
          deviceInfo: {
            ...deviceInfo,
            timestamp: new Date().toISOString(),
            ipAddress: await getClientIP()
          }
        },
        options: {
          timeout: 10000,
          retries: 2,
          protocol: 'auto' // Will try QUIC -> gRPC -> HTTP
        }
      });

      if (response.requiresTwoFactor) {
        throw new Error('TWO_FACTOR_REQUIRED');
      }

      if (response.user && response.session) {
        // Log successful login to audit trail
        await logAuthEvent({
          action: 'login',
          userId: response.user.id,
          success: true,
          details: {
            deviceInfo,
            rememberMe,
            protocol: response.metadata?.protocol
          }
        });

        return { user: response.user, session: response.session };
      }

      throw new Error(response.error || 'Login failed');
    } catch (error: any) {
      // Log failed login attempt
      await logAuthEvent({
        action: 'login',
        success: false,
        details: {
          email,
          error: error.message,
          deviceInfo
        }
      });

      if (error.message === 'TWO_FACTOR_REQUIRED') {
        throw new Error('TWO_FACTOR_REQUIRED');
      }

      throw new Error(error.message || 'Login failed');
    }
  },

  // Registration service with legal professional validation
  register: async (context: AuthContext, event: any) => {
    const registrationData = event.data;

    try {
      // Enhanced registration with legal professional verification
      const response = await productionServiceClient.request({
        method: 'POST',
        path: '/auth/register',
        body: {
          ...registrationData,
          metadata: {
            registrationType: 'legal_professional',
            validationLevel: 'enhanced',
            timestamp: new Date().toISOString()
          }
        },
        options: {
          timeout: 15000,
          retries: 1,
          protocol: 'auto'
        }
      });

      if (response.user) {
        // Log successful registration
        await logAuthEvent({
          action: 'register',
          userId: response.user.id,
          success: true,
          details: {
            role: registrationData.role,
            department: registrationData.department,
            jurisdiction: registrationData.jurisdiction
          }
        });

        return { user: response.user };
      }

      throw new Error(response.error || 'Registration failed');
    } catch (error: any) {
      // Log failed registration
      await logAuthEvent({
        action: 'register',
        success: false,
        details: {
          email: registrationData.email,
          error: error.message,
          role: registrationData.role
        }
      });

      throw new Error(error.message || 'Registration failed');
    }
  },

  // Session validation service
  validateSession: async (context: AuthContext) => {
    try {
      const response = await productionServiceClient.request({
        method: 'GET',
        path: '/auth/session',
        options: {
          timeout: 5000,
          protocol: 'auto'
        }
      });

      return {
        user: response.user,
        session: response.session,
        valid: response.valid
      };
    } catch (error) {
      return { valid: false };
    }
  },

  // Logout service
  logout: async (context: AuthContext) => {
    try {
      await productionServiceClient.request({
        method: 'POST',
        path: '/auth/logout',
        options: {
          timeout: 5000,
          protocol: 'auto'
        }
      });

      // Log logout
      if (context.user?.id) {
        await logAuthEvent({
          action: 'logout',
          userId: context.user.id,
          success: true,
          details: {}
        });
      }

      return { success: true };
    } catch (error) {
      // Still return success for logout even if server call fails
      return { success: true };
    }
  }
};

// Helper functions
async function getClientIP(): Promise<string> {
  try {
    // This would normally get the real client IP
    // For now, return a placeholder
    return '127.0.0.1';
  } catch {
    return '127.0.0.1';
  }
}

async function logAuthEvent(event: {
  action: string;
  userId?: string;
  success: boolean;
  details: any;
}): Promise<void> {
  try {
    await productionServiceClient.request({
      method: 'POST',
      path: '/auth/audit',
      body: {
        ...event,
        timestamp: new Date().toISOString(),
        userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : 'server'
      },
      options: {
        timeout: 3000,
        protocol: 'auto'
      }
    });
  } catch (error) {
    console.warn('Failed to log auth event:', error);
  }
}

// Authentication state machine
export const authMachine = createMachine({
  id: 'auth',
  types: {} as {
    context: AuthContext,
    events: AuthEvent
  },
  context: {
    user: null,
    session: null,
    error: undefined,
    isLoading: false,
    loginAttempts: 0,
    maxLoginAttempts: 5,
    twoFactorRequired: false,
    registrationData: undefined
  },
  initial: 'idle',
  states: {
    idle: {
      on: {
        START_LOGIN: {
          target: 'authenticating',
          actions: assign({
            isLoading: true,
            error: undefined
          })
        },
        START_REGISTRATION: {
          target: 'registering',
          actions: assign({
            isLoading: true,
            error: undefined,
            registrationData: (_context, event) => (event as any).data
          })
        },
        LOGOUT: {
          target: 'loggingOut'
        }
      }
    },

    authenticating: {
      invoke: {
        src: 'login',
        onDone: [
          {
            target: 'authenticated',
            actions: assign({
              user: (_context, event) => (event as any).data.user,
              session: (_context, event) => (event as any).data.session,
              isLoading: false,
              error: undefined,
              loginAttempts: 0
            })
          }
        ],
        onError: [
          {
            target: 'requiresTwoFactor',
            guard: (_context, event) => (event as any).data?.message === 'TWO_FACTOR_REQUIRED',
            actions: assign({
              twoFactorRequired: () => true,
              isLoading: () => false
            })
          },
          {
            target: 'accountLocked',
            guard: (context, _event) => {
              const newAttempts = context.loginAttempts + 1;
              return newAttempts >= context.maxLoginAttempts;
            },
            actions: assign({
              loginAttempts: (context) => context.loginAttempts + 1,
              lockoutUntil: () => new Date(Date.now() + 15 * 60 * 1000), // 15 minutes
              isLoading: () => false,
              error: () => 'Account locked due to too many failed attempts'
            })
          },
          {
            target: 'error',
            actions: assign({
              error: (_context, event) => (event as any).data?.message || 'Login failed',
              loginAttempts: (context) => context.loginAttempts + 1,
              lastLoginAttempt: () => new Date(),
              isLoading: () => false
            })
          }
        ]
      }
    },

    registering: {
      invoke: {
        src: 'register',
        onDone: {
          target: 'requiresVerification',
          actions: assign({
            user: (_context, event) => (event as any).data.user,
            isLoading: () => false,
            error: () => undefined
          })
        },
        onError: {
          target: 'error',
          actions: assign({
            error: (_context, event) => (event as any).data?.message || 'Registration failed',
            isLoading: () => false
          })
        }
      }
    },

    authenticated: {
      entry: assign({
        isLoading: () => false,
        error: () => undefined,
        twoFactorRequired: () => false
      }),
      on: {
        LOGOUT: {
          target: 'loggingOut'
        },
        SESSION_EXPIRED: {
          target: 'idle',
          actions: assign({
            user: () => null,
            session: () => null,
            error: () => 'Session expired. Please login again.'
          })
        },
        UPDATE_PROFILE: {
          target: 'updatingProfile'
        }
      }
    },

    requiresTwoFactor: {
      on: {
        START_LOGIN: {
          target: 'authenticating',
          actions: assign({
            isLoading: true,
            error: undefined
          })
        },
        TWO_FACTOR_SUCCESS: {
          target: 'authenticated',
          actions: assign({
            session: (_context, event) => (event as any).data.session,
            twoFactorRequired: () => false,
            isLoading: () => false
          })
        },
        TWO_FACTOR_FAILURE: {
          target: 'error',
          actions: assign({
            error: (_context, event) => (event as any).data?.error,
            isLoading: () => false
          })
        }
      }
    },

    requiresVerification: {
      on: {
        VERIFY_EMAIL: {
          target: 'verifyingEmail'
        },
        EMAIL_VERIFIED: {
          target: 'idle',
          actions: assign({
            error: () => undefined
          })
        }
      }
    },

    verifyingEmail: {
      // This would invoke an email verification service
      on: {
        EMAIL_VERIFIED: {
          target: 'idle'
        }
      }
    },

    loggingOut: {
      invoke: {
        src: 'logout',
        onDone: {
          target: 'idle',
          actions: assign({
            user: () => null,
            session: () => null,
            isLoading: () => false,
            error: () => undefined,
            twoFactorRequired: () => false
          })
        },
        onError: {
          target: 'idle',
          actions: assign({
            user: () => null,
            session: () => null,
            isLoading: () => false,
            error: () => undefined,
            twoFactorRequired: () => false
          })
        }
      }
    },

    accountLocked: {
      after: {
        900000: { // 15 minutes
          target: 'idle',
          actions: assign({
            loginAttempts: () => 0,
            lockoutUntil: () => undefined,
            error: () => undefined
          })
        }
      },
      on: {
        UNLOCK_ACCOUNT: {
          target: 'idle',
          actions: assign({
            loginAttempts: () => 0,
            lockoutUntil: () => undefined,
            error: () => undefined
          })
        }
      }
    },

    updatingProfile: {
      // This would invoke a profile update service
      on: {
        PROFILE_UPDATED: {
          target: 'authenticated',
          actions: assign({
            user: (_context, event) => ({ ...(event as any).data }),
            isLoading: () => false
          })
        }
      }
    },

    error: {
      on: {
        RETRY: {
          target: 'idle',
          actions: assign({
            error: () => undefined,
            isLoading: () => false
          })
        },
        START_LOGIN: {
          target: 'authenticating',
          actions: assign({
            error: () => undefined,
            isLoading: () => true
          })
        },
        START_REGISTRATION: {
          target: 'registering',
          actions: assign({
            error: () => undefined,
            isLoading: () => true
          })
        }
      }
    }
  }
}, {
  services: authServices
});

// Export types for use in components
export type { AuthContext, AuthEvent, LoginData, RegistrationData };